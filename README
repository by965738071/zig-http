# Zig HTTP Server 框架设计文档

基于 Zig 标准库 HTTP 模块和异步 I/O 的高性能 HTTP Server 框架

## 目录
- [核心架构](#核心架构)
- [HTTP 模块分析](#http-模块分析)
- [异步 I/O 集成](#异步-io-集成)
- [框架设计](#框架设计)
- [API 设计](#api-设计)
- [使用示例](#使用示例)

---

## HTTP 模块分析

### Zig 标准库 HTTP 结构

```
std.http/
├── Client.zig      # HTTP 客户端 (68KB)
├── Server.zig      # HTTP 服务器 (30KB)
├── HeadParser.zig  # HTTP 头解析器 (12KB)
├── ChunkParser.zig # 分块传输编码 (3.7KB)
├── HeaderIterator.zig # 头迭代器 (3KB)
└── test.zig       # 测试 (46KB)
```

### 核心类型

```zig
// HTTP 方法
pub const Method = enum {
    GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH,
    
    // 方法属性
    pub fn requestHasBody(m: Method) bool
    pub fn responseHasBody(m: Method) bool
    pub fn safe(m: Method) bool          // 安全方法(GET/HEAD/OPTIONS/TRACE)
    pub fn idempotent(m: Method) bool    // 幂等方法
    pub fn cacheable(m: Method) bool      // 可缓存方法
};

// HTTP 状态码
pub const Status = enum(u10) {
    ok = 200,
    created = 201,
    bad_request = 400,
    not_found = 404,
    internal_server_error = 500,
    // ... 50+ 状态码
    
    pub fn phrase(self: Status) ?[]const u8
};

// HTTP 服务器
pub const Server = struct {
    out: *Writer,        // 输出流
    reader: http.Reader, // 输入流解析器
    
    pub fn init(in: *Reader, out: *Writer) Server
    pub fn receiveHead(s: *Server) ReceiveHeadError!Request
    
    pub const Request = struct {
        server: *Server,
        head: Head,
        head_buffer: []const u8,
        
        pub const Head = struct {
            method: http.Method,
            target: []const u8,
            version: http.Version,
            content_type: ?[]const u8,
            content_length: ?u64,
            transfer_encoding: http.TransferEncoding,
            keep_alive: bool,
            // ...
        };
        
        // 响应方法
        pub fn respond(req: *Request, body: []const u8, options: RespondOptions) !void
        pub fn respondStreaming(req: *Request, headers: []const Header, options: RespondOptions) !Response
    };
};
```

### 关键特性

1. **连接复用**: HTTP/1.1 Keep-Alive 自动支持
2. **流式处理**: 支持流式请求/响应
3. **分块编码**: 自动处理 Transfer-Encoding: chunked
4. **Trailers**: 支持 HTTP 尾部信息
5. **状态机**: HeadParser 使用有限状态机解析

---

## 异步 I/O 集成

### std.Io 核心接口

```zig
pub const Io = struct {
    // 异步执行(Fire-and-forget)
    pub fn async(io: Io, func: anytype, args: anytype) void
    
    // 并发任务(可等待)
    pub fn concurrent(io: Io, func: anytype, args: anytype) !*AnyFuture
    
    // 阻塞等待
    pub fn await(io: Io, future: *AnyFuture) !Future.Value
    
    // 并发组
    pub const Group = struct {
        pub fn init() Group
        pub fn async(group: *Group, io: Io, func: anytype, args: anytype) void
        pub fn await(group: *Group, io: Io) !void
    };
    
    // 网络
    pub const net = struct {
        pub const Server = struct {
            pub fn listen(allocator: Allocator, address: IpAddress, options: ListenOptions) !Server
            pub fn accept(server: *Server, io: Io) !Stream
            pub fn close(server: *Server, io: Io) void
        };
        
        pub const Stream = struct {
            pub fn reader(stream: *Stream, io: Io, buffer: []u8) Reader
            pub fn writer(stream: *Stream, io: Io, buffer: []u8) Writer
            pub fn close(stream: *Stream, io: Io) void
        };
    };
};
```

### 异步模式选择

| 平台 | 调度器 | 特点 |
|------|---------|------|
| macOS/BSD | Kqueue | 事件驱动,高效 |
| Linux | IoUring | 批量 I/O,零拷贝 |
| Windows | IOCP | 完成端口模型 |
| WASM | Threaded | 简化实现 |

---

## 框架设计

### 整体架构

```
┌─────────────────────────────────────────────────────┐
│             用户应用层                          │
│  (路由、中间件、处理器)                        │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│           HTTPServer 框架                      │
│  ┌────────────────────────────────────┐        │
│  │  Router (路由匹配)                 │        │
│  │  - Trie 树                        │        │
│  │  - 动态参数                       │        │
│  │  - 中间件链                       │        │
│  └──────────────┬───────────────────┘        │
│  ┌──────────────▼───────────────────┐        │
│  │  Middleware Pipeline             │        │
│  │  - 请求处理前                   │        │
│  │  - 请求处理后                   │        │
│  │  - 错误处理                     │        │
│  └──────────────┬───────────────────┘        │
│  ┌──────────────▼───────────────────┐        │
│  │  Connection Pool                │        │
│  │  - 连接复用                    │        │
│  │  - 超时管理                    │        │
│  └──────────────┬───────────────────┘        │
└─────────────────┼───────────────────────────────┘
                  │
┌─────────────────▼───────────────────────────────┐
│          Zig 标准库                             │
│  ┌────────────────────────────────────┐        │
│  │  std.http.Server                 │        │
│  │  - HTTP 解析                    │        │
│  │  - 响应生成                    │        │
│  └──────────────┬───────────────────┘        │
│  ┌──────────────▼───────────────────┐        │
│  │  std.Io                        │        │
│  │  - 异步调度                     │        │
│  │  - 网络 I/O                    │        │
│  └────────────────────────────────────┘        │
└──────────────────────────────────────────────────┘
```

### 核心组件

#### 1. HTTPServer

```zig
pub const HTTPServer = struct {
    allocator: Allocator,
    io: Io,
    tcp_server: Io.net.Server,
    router: Router,
    middlewares: std.ArrayList(*Middleware),
    config: Config,
    
    // 配置
    pub const Config = struct {
        host: []const u8 = "0.0.0.0",
        port: u16 = 8080,
        max_connections: usize = 1000,
        request_timeout: u64 = 30_000, // 30s
        read_buffer_size: usize = 8192,
        write_buffer_size: usize = 4096,
    };
    
    // 生命周期
    pub fn init(allocator: Allocator, config: Config) !HTTPServer
    pub fn deinit(server: *HTTPServer) void
    pub fn start(server: *HTTPServer) !void
    pub fn stop(server: *HTTPServer) void
    
    // 路由和中间件
    pub fn use(server: *HTTPServer, middleware: *Middleware) void
    pub fn get(server: *HTTPServer, path: []const u8, handler: Handler) void
    pub fn post(server: *HTTPServer, path: []const u8, handler: Handler) void
    pub fn put(server: *HTTPServer, path: []const u8, handler: Handler) void
    pub fn delete(server: *HTTPServer, path: []const u8, handler: Handler) void
    pub fn all(server: *HTTPServer, path: []const u8, handler: Handler) void
};
```

#### 2. Router

```zig
pub const Router = struct {
    allocator: Allocator,
    root: *RouteNode,
    
    // Trie 树节点
    pub const RouteNode = struct {
        children: std.StringHashMap(*RouteNode),
        param_child: ?*RouteNode,  // 动态参数 :id
        wildcard_child: ?*RouteNode, // 通配符 *
        handler: ?Handler,
        middlewares: std.ArrayList(*Middleware),
    };
    
    pub fn init(allocator: Allocator) !Router
    pub fn deinit(router: *Router) void
    pub fn addRoute(router: *Router, method: http.Method, path: []const u8, handler: Handler) !void
    pub fn findRoute(router: *Router, method: http.Method, path: []const u8) ?Route
    pub fn addMiddleware(router: *Router, path: []const u8, middleware: *Middleware) !void
    
    pub const Route = struct {
        handler: Handler,
        params: ParamList,
        middlewares: []*Middleware,
    };
    
    pub const ParamList = struct {
        data: std.StringHashMap([]const u8),
        pub fn get(list: ParamList, name: []const u8) ?[]const u8
    };
};
```

#### 3. Middleware

```zig
pub const Middleware = struct {
    name: []const u8,
    vtable: *const VTable,
    
    pub const VTable = struct {
        process: *const fn (*anyopaque, *Context) anyerror!NextAction,
        destroy: *const fn (*anyopaque) void,
    };
    
    pub const NextAction = enum {
        continue,  // 继续下一个中间件
        respond,   // 立即响应,不继续
        error,     // 错误处理
    };
    
    pub fn init(comptime T: type, middleware: T) Middleware {
        return .{
            .name = @typeName(T),
            .vtable = &.{
                .process = struct {
                    fn process(ptr: *anyopaque, ctx: *Context) !NextAction {
                        const self: *T = @ptrCast(@alignCast(ptr));
                        return self.process(ctx);
                    }
                }.process,
                .destroy = struct {
                    fn destroy(ptr: *anyopaque) void {
                        const self: *T = @ptrCast(@alignCast(ptr));
                        self.deinit();
                    }
                }.destroy,
            },
        };
    }
};

// 中间件示例
pub const LoggingMiddleware = struct {
    middleware: Middleware,
    
    pub fn init(allocator: Allocator) !*LoggingMiddleware {
        const self = try allocator.create(LoggingMiddleware);
        self.* = .{
            .middleware = Middleware.init(LoggingMiddleware, self),
        };
        return self;
    }
    
    pub fn process(self: *LoggingMiddleware, ctx: *Context) !NextAction {
        const start = std.time.nanoTimestamp();
        defer {
            const elapsed = std.time.nanoTimestamp() - start;
            std.log.info("{s} {s} - {d}ns", .{
                @tagName(ctx.request.head.method),
                ctx.request.head.target,
                elapsed,
            });
        };
        return .continue;
    }
    
    pub fn deinit(self: *LoggingMiddleware) void {}
};

pub const CORSMiddleware = struct {
    middleware: Middleware,
    allowed_origins: []const []const u8,
    
    pub fn init(allocator: Allocator, origins: []const []const u8) !*CORSMiddleware {
        const self = try allocator.create(CORSMiddleware);
        self.* = .{
            .middleware = Middleware.init(CORSMiddleware, self),
            .allowed_origins = origins,
        };
        return self;
    }
    
    pub fn process(self: *CORSMiddleware, ctx: *Context) !NextAction {
        // 设置 CORS 头
        try ctx.response.headers.append(.{
            .name = "Access-Control-Allow-Origin",
            .value = "*",
        });
        return .continue;
    }
    
    pub fn deinit(self: *CORSMiddleware) void {}
};
```

#### 4. Context

```zig
pub const Context = struct {
    server: *HTTPServer,
    request: *http.Server.Request,
    response: *Response,
    params: ParamList,
    state: std.StringHashMap(*anyopaque),
    
    // 便捷方法
    pub fn getParam(ctx: *Context, name: []const u8) ?[]const u8
    pub fn getQuery(ctx: *Context, name: []const u8) ?[]const u8
    pub fn getHeader(ctx: *Context, name: []const u8) ?[]const u8
    pub fn setState(ctx: *Context, key: []const u8, value: anytype) !void
    pub fn getState(ctx: *Context, key: []const u8) ?*anyopaque
    pub fn json(ctx: *Context, value: anytype) !void
    pub fn html(ctx: *Context, content: []const u8) !void
    pub fn status(ctx: *Context, status: http.Status) void
    pub fn error(ctx: *Context, status: http.Status, message: []const u8) !void
};

pub const Response = struct {
    status: http.Status = .ok,
    headers: std.ArrayList(http.Header),
    body: std.ArrayList(u8),
    
    pub fn init(allocator: Allocator) !Response
    pub fn deinit(res: *Response) void
    pub fn write(res: *Response, data: []const u8) !void
    pub fn writeJSON(res: *Response, value: anytype) !void
    pub fn setStatus(res: *Response, status: http.Status) void
    pub fn setHeader(res: *Response, name: []const u8, value: []const u8) !void
    pub fn toHttpResponse(res: *Response, request: *http.Server.Request) !void
};
```

#### 5. Handler

```zig
pub const Handler = *const fn (ctx: *Context) anyerror!void;

// 处理器示例
fn helloHandler(ctx: *Context) !void {
    try ctx.json(.{
        .message = "Hello, World!",
        .method = @tagName(ctx.request.head.method),
        .path = ctx.request.head.target,
    });
}

fn getUserHandler(ctx: *Context) !void {
    const user_id = ctx.getParam("id") orelse {
        try ctx.status(.bad_request);
        try ctx.json(.{ .error = "Missing user ID" });
        return;
    };
    
    // 模拟数据库查询
    const user = .{
        .id = user_id,
        .name = "John Doe",
        .email = "john@example.com",
    };
    
    try ctx.json(user);
}
```

---

## API 设计

### 基础 API

```zig
// 创建服务器
const std = @import("std");
const http = std.http;
const http_server = @import("http_server.zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{});
    defer _ = gpa.deinit();
    
    var io_threaded = try std.Io.Threaded.init(gpa.allocator(), .{
        .argv0 = std.os.argv[0],
        .environ = std.os.environ,
    });
    defer io_threaded.deinit();
    
    var server = try http_server.HTTPServer.init(gpa.allocator(), .{
        .host = "0.0.0.0",
        .port = 8080,
        .max_connections = 1000,
    });
    defer server.deinit();
    
    // 全局中间件
    const logger = try http_server.LoggingMiddleware.init(gpa.allocator());
    defer logger.deinit();
    server.use(logger);
    
    const cors = try http_server.CORSMiddleware.init(gpa.allocator(), &.{"*"});
    defer cors.deinit();
    server.use(cors);
    
    // 路由
    server.get("/", helloHandler);
    server.get("/users/:id", getUserHandler);
    server.post("/users", createUserHandler);
    server.put("/users/:id", updateUserHandler);
    server.delete("/users/:id", deleteUserHandler);
    
    // 启动服务器
    try server.start();
}
```

### 链式 API

```zig
const server = http_server.HTTPServer.builder(gpa.allocator())
    .host("0.0.0.0")
    .port(8080)
    .max_connections(1000)
    .use(&LoggingMiddleware{})
    .use(&CORSMiddleware{})
    .get("/", helloHandler)
    .get("/users/:id", getUserHandler)
    .group("/api", .{
        .middlewares = &.{&AuthMiddleware{}},
    }, |api| {
        api.get("/users", listUsersHandler);
        api.post("/users", createUserHandler);
    })
    .build();
```

### 路由组

```zig
server.group("/api/v1", &.{&AuthMiddleware{}}, |group| {
    group.get("/users", listUsersHandler);
    group.post("/users", createUserHandler);
    
    group.group("/posts", &.{&PostMiddleware{}}, |posts| {
        posts.get("/", listPostsHandler);
        posts.get("/:id", getPostHandler);
        posts.post("/", createPostHandler);
        posts.delete("/:id", deletePostHandler);
    });
});
```

### 中间件链

```zig
// 请求处理前中间件
pub const TimingMiddleware = struct {
    pub fn process(self: *TimingMiddleware, ctx: *Context) !NextAction {
        ctx.setState("start_time", std.time.nanoTimestamp());
        return .continue;
    }
};

// 请求处理后中间件
pub const ResponseTimingMiddleware = struct {
    pub fn process(self: *ResponseTimingMiddleware, ctx: *Context) !NextAction {
        const start = ctx.getState("start_time") orelse return .continue;
        const elapsed = std.time.nanoTimestamp() - @intFromPtr(start);
        
        ctx.response.setHeader("X-Response-Time", elapsed);
        return .continue;
    }
};
```

---

## 高并发设计

### 连接处理模型

```zig
// 主服务器循环
pub fn start(server: *HTTPServer) !void {
    const io = server.io;
    
    while (server.running) {
        // 异步接受连接
        const stream = io.accept(server.tcp_server) catch |err| {
            std.log.err("Accept failed: {}", .{err});
            continue;
        };
        
        // 并发处理连接
        if (server.connection_pool.active < server.config.max_connections) {
            _ = io.concurrent(handleConnection, .{ server, stream });
        } else {
            stream.close(io);
        }
    }
}

// 处理单个连接
fn handleConnection(
    server: *HTTPServer,
    stream: Io.net.Stream,
) !void {
    const io = server.io;
    defer stream.close(io);
    
    var read_buffer: [8192]u8 = undefined;
    var write_buffer: [4096]u8 = undefined;
    
    var reader = stream.reader(io, &read_buffer);
    var writer = stream.writer(io, &write_buffer);
    var http_server = http.Server.init(&reader.interface, &writer.interface);
    
    // Keep-Alive 循环
    while (true) {
        const request = http_server.receiveHead() catch |err| {
            if (err == error.EndOfStream) break;
            return err;
        };
        
        // 处理请求
        try handleRequest(server, &request);
        
        if (!request.head.keep_alive) break;
    }
}

// 处理单个请求
fn handleRequest(server: *HTTPServer, request: *http.Server.Request) !void {
    var response = try Response.init(server.allocator);
    defer response.deinit();
    
    var context = Context{
        .server = server,
        .request = request,
        .response = &response,
        .params = .{},
        .state = std.StringHashMap(*anyopaque).init(server.allocator),
    };
    defer context.state.deinit();
    
    // 路由匹配
    const route = server.router.findRoute(
        request.head.method,
        request.head.target,
    ) orelse {
        try context.status(.not_found);
        try context.json(.{ .error = "Not found" });
        return;
    };
    
    // 执行中间件链
    for (route.middlewares) |middleware| {
        const action = try middleware.vtable.process(middleware, &context);
        switch (action) {
            .continue => continue,
            .respond, .error => return,
        }
    }
    
    // 执行处理器
    try route.handler(&context);
    
    // 发送响应
    try response.toHttpResponse(request);
}
```

---

## 性能优化

### 1. 内存池

```zig
pub const ResponsePool = struct {
    allocator: Allocator,
    pool: std.ArrayList(*Response),
    mutex: std.Thread.Mutex,
    
    pub fn init(allocator: Allocator, size: usize) ResponsePool {
        return .{
            .allocator = allocator,
            .pool = std.ArrayList(*Response).init(allocator),
            .mutex = .{},
        };
    }
    
    pub fn acquire(pool: *ResponsePool) !*Response {
        pool.mutex.lock();
        defer pool.mutex.unlock();
        
        if (pool.pool.popOrNull()) |resp| return resp;
        
        const resp = try pool.allocator.create(Response);
        resp.* = try Response.init(pool.allocator);
        return resp;
    }
    
    pub fn release(pool: *ResponsePool, resp: *Response) void {
        resp.reset(); // 重置状态
        pool.mutex.lock();
        defer pool.mutex.unlock();
        pool.pool.append(resp) catch |err| {
            pool.allocator.destroy(resp);
            std.log.err("Failed to return to pool: {}", .{err});
        };
    }
};
```

### 2. 零拷贝缓冲区

```zig
pub const ZeroCopyBuffer = struct {
    data: []const u8,
    slices: std.ArrayList(struct { start: usize, end: usize }),
    
    pub fn fromReader(reader: *Reader, buffer: []u8) !ZeroCopyBuffer {
        // 直接使用读取缓冲区,不复制
        return .{
            .data = buffer,
            .slices = std.ArrayList(struct { start: usize, end: usize }).init(reader.allocator),
        };
    }
    
    pub fn write(self: *ZeroCopyBuffer, writer: *Writer) !void {
        for (self.slices.items) |slice| {
            try writer.writeAll(self.data[slice.start..slice.end]);
        }
    }
};
```

### 3. SIMD 优化路由匹配

```zig
pub fn fastPathMatch(path: []const u8, pattern: []const u8) bool {
    const vector_len = std.simd.suggestVectorLength(u8) orelse 1;
    const min_len = @min(path.len, pattern.len);
    
    var i: usize = 0;
    while (i + vector_len <= min_len) : (i += vector_len) {
        const path_vec = @as(*[vector_len]u8, @ptrCast(path.ptr + i)).*;
        const pattern_vec = @as(*[vector_len]u8, @ptrCast(pattern.ptr + i)).*;
        
        if (!std.simd.eql(u8, path_vec, pattern_vec)) return false;
    }
    
    // 处理剩余字节
    while (i < min_len) : (i += 1) {
        if (path[i] != pattern[i]) return false;
    }
    
    return true;
}
```

---

## 完整示例

### Restful API 服务器

```zig
const std = @import("std");
const http = std.http;
const http_server = @import("http_server.zig");

const User = struct {
    id: []const u8,
    name: []const u8,
    email: []const u8,
};

var users = std.StringHashMap(User).init(std.heap.page_allocator);

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{});
    defer _ = gpa.deinit();
    
    var io_threaded = try std.Io.Threaded.init(gpa.allocator(), .{...});
    defer io_threaded.deinit();
    
    var server = try http_server.HTTPServer.init(gpa.allocator(), .{
        .port = 8080,
    });
    defer server.deinit();
    
    // 中间件
    server.use(try http_server.LoggingMiddleware.init(gpa.allocator()));
    server.use(try http_server.CORSMiddleware.init(gpa.allocator(), &.{"*"}));
    
    // 路由
    server.get("/users", listUsers);
    server.get("/users/:id", getUser);
    server.post("/users", createUser);
    server.put("/users/:id", updateUser);
    server.delete("/users/:id", deleteUser);
    
    try server.start();
}

fn listUsers(ctx: *http_server.Context) !void {
    var user_list = std.ArrayList(User).init(ctx.server.allocator);
    defer user_list.deinit();
    
    var iter = users.iterator();
    while (iter.next()) |entry| {
        try user_list.append(entry.value_ptr.*);
    }
    
    try ctx.json(user_list.items);
}

fn getUser(ctx: *http_server.Context) !void {
    const id = ctx.getParam("id") orelse return error.NotFound;
    
    const user = users.get(id) orelse {
        try ctx.status(.not_found);
        try ctx.json(.{ .error = "User not found" });
        return;
    };
    
    try ctx.json(user);
}

fn createUser(ctx: *http_server.Context) !void {
    // 解析 JSON body
    const body = try ctx.request.reader(&.{}).allocRemaining(ctx.server.allocator, .unlimited);
    defer ctx.server.allocator.free(body);
    
    const user = try std.json.parseFromSlice(User, ctx.server.allocator, body, .{});
    defer std.json.parseFree(User, ctx.server.allocator, user);
    
    // 生成 ID
    const id = try std.fmt.allocPrint(ctx.server.allocator, "{d}", .{std.time.nanoTimestamp()});
    defer ctx.server.allocator.free(id);
    
    var owned_user = try ctx.server.allocator.create(User);
    owned_user.* = .{
        .id = id,
        .name = try ctx.server.allocator.dupe(u8, user.name),
        .email = try ctx.server.allocator.dupe(u8, user.email),
    };
    
    try users.put(id, owned_user.*);
    
    try ctx.status(.created);
    try ctx.json(owned_user.*);
}

// ... 其他处理器
```

---

## 总结

这个 HTTP Server 框架结合了:

✅ **Zig 标准库 HTTP**: 完整的 HTTP 解析和响应生成  
✅ **异步 I/O**: 高并发,低延迟  
✅ **灵活路由**: Trie 树,动态参数  
✅ **中间件系统**: 可组合的请求处理  
✅ **高性能**: 连接池,零拷贝,SIMD 优化  
✅ **友好 API**: 链式调用,类型安全  

下一步我将实现完整代码!
